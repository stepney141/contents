# 【翻訳】Meet the Dagaz 〜汎用ボードゲームソフトウェアの開発〜

※この文章は、ヴァレンティン・チェルノコフ(Валентин Челноков)氏が["Abstract Games"](http://www.abstractgames.org/)誌に投稿した["Meet the Dagaz!"](http://www.abstractgames.org/dagaz.html)を、チェルノコフ氏に許可を頂き和訳したものです。
翻訳された文章に関する全ての責任は訳者に帰属します。誤訳等がありましたら訳者までご指摘頂ければ幸いです。

- 原著者：Valentin Chelnokov
- 日本語訳：ゆみや（Twitter:[@stepney141](https://twitter.com/stepney141)）
- ソース：[Dagaz - THE NEW ABSTRACT GAMES](http://www.abstractgames.org/dagaz.html)

----

私が名付けた"Dagaz"というプロジェクト名は、全23個の古代ルーン文字のひとつ"ᛞ"に由来しています。この文字が持つ意味の解釈の一つは「復活(revival)」です。
このルーン文字の形は個人的にボードゲームの駒を連想させますし、さらには「ゲームを遊ぶ人・ゲームを作る人双方のための汎用的なゲームソフトウェアを作り、これを用いてアブストラクト・ゲームにより興味を持ってもらいたい」――私のそのような考えが、文字の意味ともぴったり対応しているように思われるのです。

2つの出来事がきっかけで、私はボードゲームにのめり込むようになりました。
1つ目は、ドミトリー・スキュルーク氏(彼はロシアの作家で、囲碁・チェッカー・マンカラ系ゲーム(中でもアフリカに分布する系統のもの)の偉大な愛好家です)にお会いしたこと。
2つ目は、それと同時期に"Zillions of Games"(訳注：以下、"ZoG"と表記[^zog])という汎用ボードゲームソフトウェアに出会ったことです。
運の悪いことに、私がこのソフトを知った頃には既に、ZoGに対する界隈の関心は衰え始めていました。
ですが私はそんな状況を尻目に、ZoG上にいくつものゲームを実装しては、ZoGについての解説記事を大量に執筆するという活動を続けました。
ZoGでゲームを実装する際には、"Zillions Rules File"(以下、省略して"ZRF"と表記します)という独自のスクリプト言語を使用してゲームのルールを記述するのですが、ZRFの強力さにはまさしく心を揺さぶられるものがありました。
ルールも見かけも全く異なる別々のゲームをこんなにも沢山作れるなんて、それ以前の私にはまるで想像もつかないことだったのです。

しかし、ZRFの扱いに習熟すればするほど、私はその欠点にもだんだんと気付いていくこととなりました。
その欠点とは、「ZRFで簡単に実装することが出来るのは、極めて単純な――特にチェッカーやチェスに類似している――ルールのゲームのみである」ということです。
マンカラなどをはじめとしたより複雑なゲームをZRFで実装しようとすると、ルールの記述は巨大で漠然としたものになり、動作も低速かつ信頼性に欠けるものになってしまいます。
この問題に直面した私は解決策を求めて、"Axiom Development Kit"を使いこなすようになりました。
これはグレッグ・シュミット氏が開発したZoGの拡張プラグインで、DLLファイルとしてZoGに読み込ませることで動作します。
Axiomを用いることで[リスモマチア(Rithmomachia)](https://glukkazan.github.io/elimination/rithmomachia.htm)（[AG15](http://www.abstractgames.org/uploads/1/1/6/4/116462923/abstract_games_issue_15.pdf)を参照）などの比較的複雑なゲームも実装できるようにはなったのですが、これを使っても実装はやはり難解で時間を食うものになってしまうのです。
まだこの他にも欠点があります。というのは、AxiomとZoGはいずれもWindows上でしか動作しないのです。しかし私が求めていたのは、クロスプラットフォーム対応でどこでも動く、何ならスマートフォン上でも動作するソフトウェアでした。

以上のような欠点を解消したいという視点で考えると、開発に利用できる技術は自ずと限られてきます。
ほとんどあらゆるモダンなWebブラウザがネイティブにサポートしているプログラミング言語と言えばただひとつ、それはJavaScriptです。
Javaアプレットを触るという選択肢は取りたくありませんでした。何しろ、今や時代遅れで不便な技術ですからね。
Web Assemblyもまた、別の理由から私にとっては適しませんでした。
というのも、私の目標は「あらゆるユーザーが自由にオープンソースのコードを参照でき、ソフトの仕組みを理解して、ZoG同様にしかしずっと簡単に自分でゲームが作れるようにする」ことでしたから。

もちろん完璧なアプローチというものは存在しない訳で、当然このアプローチにも欠点はあります。C++やJavaといったプログラミング言語と比較して、JavaScriptはオープン性がある代わりにパフォーマンスが比較的低いのです。
幾度も失敗を重ねた後、私は、ゲームを動かしながらZRFを直接読み込んで解釈するというのは不可能らしいということに気付きました。
これをやるとあまりにも動作が遅くなってしまうためです。
結局、私はZRFをJavaScriptに変換する"Z2J"というユーティリティを作ることでこれを解決しました。
Z2Jで変換されたルール記述のコードは「自動生成臭」が強く、人間が直接編集するには不向きな難しいものですが、それでもZRFのようにルール記述として解釈可能なようになっています。

![Russian-Checkers](http://www.abstractgames.org/uploads/1/1/6/4/116462923/d3c04648-d139-43f9-9004-4271735f73dc_orig.png)  
図1：ロシアン・チェッカー

私はまず、[ロシアン・チェッカー](https://glukkazan.github.io/checkers/russian-checkers.htm)（ルールは[こちら](https://en.wikipedia.org/wiki/Russian_draughts)を参照）から実装を始めました。
個人的に、この系統のゲームはあまりに過小評価されているという思いを常に持っていたからです。
このゲームの複雑なルールをきちんと理解できなくては、これ以上のあらゆる開発は無意味でしょう。
特に注目すべきは、「着手の複数性」のルールです。
チェッカー類では「一回の着手において、立て続けに複数回連続して駒を動かすことが出来る」というルールがありますが、これは極めて重要なことです。
他に特筆すべき性質としては「着手の優先性」が挙げられます。
チェッカー類では、もしも取ることが出来る相手の駒があるならば、必ず取らなくてはいけません。
例え相手の駒を取ることで自分が不利になるような状況であってもです。
チェッカー以後に誕生したゲームでは、この「着手の優先性」に関するルールは完全な再考と変更を迫られることになったのですが、このことがDagazプロジェクトの基礎をしっかりと形作ることになりました。

チェスについて考えた際、「複数の駒が一回の着手で一度に移動する場合がある」（例：キャスリング）ということに気付かされました。
さらに、「駒が動けるからと言って必ずしもその駒を動かしていいとは限らない」という性質もあります――例えば、キングがチェックをかけられてしまうような場所に自分からキングを動かすことは決してやってはいけないことになっています。
このため、私はチェックメイトを判定するアルゴリズムを実装する必要がありました。
チェックメイト判定（禁止手排除）はチェッカーの「着手の優先性」よりも困難です。何故なら、禁止手排除は「駒を取る手」と「駒を取らない手」の両方に適用されるからです。
また、チェッカー系ゲームでは禁止手について様々な判定基準が存在しうるため、これも単純とは程遠いと言えます。
可能な限り多く相手の駒を取らなければならないというゲームもある一方、例えば[フリジア・チェッカー](https://glukkazan.github.io/checkers/frisian-checkers.htm)（[AG10](http://www.abstractgames.org/uploads/1/1/6/4/116462923/abstract_games_issue_10.pdf)を参照）などのゲームではそれに加え、「成った（昇格した）」駒を先に取るという優先順位が設けられています。

こんな複雑な概念をZRFの判定ロジックで記述することに貴重な時間を割き、さらにそれをJavaScriptに翻訳するなんて、例えそのやり方を知っていたとしてもそんなことをしている余裕は私にはありませんでした。
とにかく、そのようにしてZ2Jで得られるコードはまるで非効率なものです。
直接JavaScriptで判定を書いてやる方がよっぽど理に適っています。
というわけで、私はZRFをあくまで駒の動きの基本的なルールを書くことのみに使い、複雑な判定は拡張機能としてJavaScriptで書くことにしました。
UIの描画が更新される前に、ゲームの初期状態から得られる合法手の一覧が、ゲーム本体のコードに接続された拡張モジュールに渡されます。
この拡張モジュールは、複雑な判定の実行・着手の選択と排除・必要に応じて追加で行う別の処理を効率的にこなすことが出来ます。

![Atari-Go](http://www.abstractgames.org/uploads/1/1/6/4/116462923/7e122c3a-240e-404e-b728-a9f576883f66_orig.png)  
図2：アタリ碁（ポン抜き囲碁）

[アタリ碁](https://glukkazan.github.io/go/atari-go.htm)[^atari-go]（ルールは[こちら](https://en.wikipedia.org/wiki/Go_variants#First_Capture)を参照）は、私が上で述べた仕組みを見事に体現しています。
囲碁の基本的な着手の仕方は大変シンプルで、石を盤上の空いた場所（交点）に置くだけです。
しかし、あらゆる場所に石を置けるという訳ではありません。自分の石の呼吸点がなくなるような手を自分から打つのは「自殺手」であり、そのような着手は禁止されています。
プレイヤーは、自分が石を置くと自分の石の呼吸点（石の上下左右方向に隣接する空白の点）が無くなってしまうような場所には、自分で石を置いてはいけません[^go-rule]。また、石の一団が活きているためには、最低一つの呼吸点を持っていなければなりません[^go-rule]。
ゲームは次のように進行します――以上の原則を踏まえ、プレイヤーが着手した際、自分が置いた石によって対戦相手の石の呼吸点が全て潰されているかどうかを判定します。もしも相手の呼吸点がなくなっていたならば、相手プレイヤーの石を取り、盤上から取り除きます（アタリ碁では、一度でも相手の石を取った時点で自分の勝利となります）。
これらの判定と確認は、ZRFで記述するにはあまりに困難かつ厖大です。

Zillions of Gamesで色々と試していた頃、私はZoGでの囲碁系ゲームの実装に関して他にも問題を見つけました。
大量の石を一度に取ると（このような状況が起こることは稀ですが、起こり得ない訳ではありません）、バッファオーバーフローが発生してソフトがクラッシュするのです。
ZoGは、各着手とそれによって発生する盤上のあらゆる変更を（ZSG棋譜という形式の）テキストとして保存します。
履歴には「この場所に石を置いた」という着手それ自体の情報のみならず、置かれた石とそれに隣接する石についてのあらゆる属性情報――どちらのプレイヤーの石か、石の位置はどこか、石は取られたか否か、など――も保存されるのです。
しかし囲碁においては、現在の盤面にたった一個でも石を置くだけで次に取られる石が完全に決定されるので、石がどこに置かれたのかさえ分かっていればそれで事足りるわけです。
囲碁やチェッカーなどのゲームでは、石を捕獲する際に石を盤上から除去する操作が伴う場合があります。Dagazではこのような捕獲を、着手の情報からゲームのルールに従って直ちに情報が求まる「副次的現象」としてみなしています。
プログラムのコア部分は、与えられたゲームのルールに則り、全ての変更と副次的現象をいつでも復元して自動で単一の変更の形に調整することが出来るようになっています。したがって、あらゆる情報を棋譜のテキスト内に詰め込む必要はありません。
結果、保存される着手の履歴は簡潔でスッキリとしたものになっています。

まだ他に1つ、Dagazが解決策を提示している既存の問題があります。それは、盤上の駒の位置をどうやって決定して画面に描画するかです。
ZoGでは「駒の属性を"Yes = 1"や"No = 0"のような感じで記述したビットフラグを複数持っておき、それらを各々の駒に割り当てる」という方法を取っていました。
これをチェスのキャスリング――ゲーム開始から今まで動いたことがないキング・ルークを一手で入れ替える操作――を例に解説しましょう。
プログラムは駒に関するビットフラグを内部に持っており、その中には「これらの駒は、キャスリングが可能な条件から外れるような動きをしたか」というフラグもあります。キングやルークの駒が動くと、このキャスリング判定用のフラグがNoからYesに切り替わり、プログラムはこれを参照して「キャスリングは出来ない」と判断するというわけです。
Dagazは、ZRFにあったような値の型に関する制限を回避しています。
真偽値以外にも、他のあらゆる種類の属性とそれに適する型を内部に持っておくことが出来るのです。
マンカラ系ゲームでは、穴(house)の中に入れる石(seeds)の数を表示するために整数型の値を使用する必要があります。

![オワレ](http://www.abstractgames.org/uploads/1/1/6/4/116462923/4f80078b-d0dd-47ba-8141-ae1536ae8cd0_orig.jpeg)  
図3：オワレ

[オワレ](https://glukkazan.github.io/mancala/oware.htm)（ルールは[こちら](https://mancala.fandom.com/wiki/Oware)を参照）はアフリカのマンカラ系ゲームの中でも最も有名なものです。
ゲームは穴(house)1つにつき各4個ずつ石(seeds)を入れた状態でスタートします。
各手番では、まずプレイヤーは自分の陣地である6つの穴（両サイドの一回り大きな穴は「スコアリング・ハウス」といいます）の中から1つを選びます。
次に、その穴の中にある石を全て取り出し、その1つ右隣の穴を起点にして半時計回りの順番で、取り出した石を各穴に1個ずつ落としていきます――このプロセスを「石撒き(sowing)」と言います。
ただし、スコアリング・ハウスには石を撒きません。またスコアリング・ハウスが石撒きの起点になることもありません。
「最後に石を撒いた穴が対戦相手の陣地にある」なおかつ「石を撒いた結果その穴に2個または3個の石が入っている」場合、自プレイヤーはその穴の中の石を全て捕獲します。捕獲した石は穴から取り除き、自分のスコアリング・ハウスの中に移します。
加えて、最後から1つ前の穴も上の条件を満たしていた場合は同じように石を捕獲し、さらにその1つ前も条件を満たしていればまた同様に...という具合で、条件を満たさない穴にぶつかるまで時計回りに遡って捕獲を続けます。
以上のルールに従い、より多くの石を捕獲して自分のスコアリング・ハウスに移すことを目指すのがこのゲームの目的です。

Zillions of Gamesでマンカラ系ゲームのロジックを実装するのには様々な困難があるというのは驚くべきことではありません。
まず1つ目のハードルは、このゲームで使う石の画像はたった1種類・1枚だけであるということです。
ZoGではプログラミング言語によって描画処理を記述することが出来ないので、ZoG側で描画をどうにかすることは不可能です。
このため、異なる数の石が穴に入っているという情報は、それぞれ別の種類の駒が存在する状態として記述してやる必要があります。どういうことかと言うと、石が1個あるという情報は内部的には駒1個が存在する状態として、石が2個以上という情報は内部的にはまた別の種類の駒が1個存在する状態として、それぞれ符号化しているのです。
この仕組みでは、対応する個数の石の組を記述するために必要な画像の数が増えます。
ZRFには整数値や整数の演算に関する機能がないので、この方法を使っても実装は依然として複雑で、通常の加算と減算をエミュレートするためにビットフラグを利用しなくてはなりません。
Axiom Development Kitでは整数演算が追加されていますが、それを使ってもなおマンカラ系ゲームの実装は難しいままです。
Dagazではこのようなゲームの構造をもっとずっと単純に記述出来るようにしました。
それに、より単純な記述ほど動作がより効率的になる傾向まであるのです。

![Column-Checkers](http://www.abstractgames.org/uploads/1/1/6/4/116462923/acf31d7b-3a0f-4fe8-8455-67ac5282e75d_orig.png)  
図4：カラム・チェッカー

[ロシアン・カラム・チェッカー](https://tinyurl.com/yb2klu48)（詳しくは[AG1](http://www.abstractgames.org/uploads/1/1/6/4/116462923/abstract_games_issue_1.pdf)などの号を参照）――バシュネ(Bashne)という名前でも知られていますが――もマンカラ系のゲームとよく類似していますが、ひとつだけ相違点があります。
それは、このチェッカーではマンカラのように石を一つの穴の中にただまとめておく訳ではなく、石を一つにまとめる順番も重要な要素になっているということです[^russian-column-checkers]。
特定の順序で配置された要素を持つ"列(column)"を表現するのは整数値だけでは不十分なため、私はDagazが内部で保存している属性に、より多くの種類の値の型を追加しました。
一つの列の中に石がどのような順番で積み重なっているのかを記述するため、Dagazでは属性情報として文字列を利用しています。
実際の所、Dagazでは配列でも他のどのようなデータ構造でも利用可能なようにはなっているのすが、外部ファイルへの保存のしやすさを考えて、文字列を使うのがベターかと個人的には思っています。
ソフトウェアレンダリングを用いて駒や石を表示するというのは、駒や石をプログラムで制御する上で非常に強力な機能でもあります。
このオプションをどう利用するかの例を解説しましょう。
囲碁には「スーパーコウ（超コウ）」というルールがあります[^super-ko]。これは、以前の盤面の状態が再び出現するような手を打ってはならないというものです。
このルールに従った禁止手を可視化するために、「禁止手になるからこの交点には石を置けないよ」という意味として盤上の交点の上に四角形を描画します。この正方形は駒や石として扱われる訳ではなく、単に画像として盤上に表示されます。
[連珠](https://glukkazan.github.io/renju/renju.htm)（[AG5](http://www.abstractgames.org/uploads/1/1/6/4/116462923/abstract_games_issue_5.pdf)と[AG6](http://www.abstractgames.org/uploads/1/1/6/4/116462923/abstract_games_issue_6.pdf)を参照）では局面に応じて禁止手も変化しますが、禁止手の可視化には囲碁と同じく、ソフトウェア側で描画される四角形の仕組みを採用しています。

![renju](http://www.abstractgames.org/uploads/1/1/6/4/116462923/3aa70857-9d32-4d4f-8a27-cdeb5d02d3a2_orig.png)  
図5：連珠

局面を前の状態に戻すことを禁止するゲームは、かなり複雑になりえます。
[モラバラバ(Morabaraba)](https://glukkazan.github.io/morris/morabaraba.htm)（ルールは[こちら](https://en.wikipedia.org/wiki/Morabaraba)を参照）というゲームは、盤上の空いている場所に自分の駒（このゲームでは"牛"と呼びます）を並べ、自分の"牛"を3匹並べた列（このゲームでは"ミル(mill)"と呼びます）を作ることを目指すものです。
プレイヤーはミルを1つ作ったら敵の牛を1匹「撃ち」、その牛を盤上から取り除きます。撃たれた牛はその時点で二度と盤上に置くことが出来なくなります。
ミルを構成している牛は、相手の牛が全てミルになっていない限り撃たれることはありません。
別の新しいミルを作るために分解されたミルは、次の手番で再びミルになることは出来ません。
図6には赤いバツ印が描かれていますが、これは直前の局面で壊されたミルの位置を表すものです。
しかし、バツ印が付けられた場所であっても、この手番でミルを再び作り直さないならば、次の手番以降でそこに牛を置くことが出来ます。

![Morabaraba](http://www.abstractgames.org/uploads/1/1/6/4/116462923/208c33cd-e246-4b0b-b898-c65386e89172_orig.png)  
図6：モラバラバ

この「盤上に駒や石とは関係ない画像を表示する」という機能は、反復同形を禁止する以外の用途にも利用することが出来ます。
ゲームの中には、ゲームに関する何らかの情報がプレイヤーに隠されたまま進行する種類のものがあります。
普通、そのような種類のゲームと言えばカードゲームなどが代表的ですが、チェス系のボードゲームでも同じ類のものがあります。
[暗闇チェス(Dark chess)](https://en.wikipedia.org/wiki/Dark_chess)というゲームでは、プレイヤーは自分の駒が利いているマス以外のマス目の情報を把握することが出来ません。
同じアイデアを他のチェス系ゲームに持ち込むことも可能です。

![dark-yonin-shogi](http://www.abstractgames.org/uploads/1/1/6/4/116462923/e99b7c9d-0c8f-46b1-bf3a-9da420784b43_orig.png)  
図7：暗闇四人将棋

[暗闇四人将棋](https://glukkazan.github.io/shogi/dark-yonin-shogi.htm)は[四人将棋](https://en.wikipedia.org/wiki/Yonin_shogi)の変種です。
四人将棋は、日本の有名な[^yonin-shogi]四人向けゲームです。
小型・中型の盤で遊ばれる他の伝統的な将棋類と同じく[^old-shogi]、四人将棋は「持ち駒」のルールがあります。これは、「獲得した相手の駒を自分が保有し、自分の駒として使用することが出来る」というものです。
盤上にある駒を動かす代わりに、プレイヤーは自分の持ち駒を盤上に新しく置くことが出来るのです。
四人将棋の場合プレイヤーは4人いるので、4枚ある王将が1枚取られてもゲームは依然として進行し続けます。
獲得した駒は王将も含めて全て自分の持ち駒となり、王将を持たないプレイヤーはそれ以上ゲームを続けることは出来ません。
そして、四人将棋は「暗闇で指す」ことも出来ます。暗闇チェスと同じように、[「戦場の霧」](https://en.wikipedia.org/wiki/Fog_of_war)という概念――すなわち「自分の駒が利いていないマスの情報を隠す」ということ――を導入したのが、暗闇四人将棋という訳です。

これらの「暗闇のゲーム」が持つ構造的な特殊性を発展させて、Dagazでは空のマス目・駒があるマス目の両方を隠すための2つの特別な機能が利用できるようになっています。駒を「半透明」の状態に出来る上、必要ならば、マス目が空かどうかに関わらず、新しいレイヤーを追加するような具合でマス目の上にさらに画像を被せることが出来るのです。
個々の駒の表示は、他の駒の利きに入っているか否かによって制御されます。
もしも敵の駒が自分の駒の利きに入っていないならばその駒は表示されませんし、自分の駒についても同じようなチェックが行われ、敵の駒の利きに入っていない自分の駒は半透明になって表示されます。
原則的には、このようなチェックをするだけで隠す必要のある駒は全て隠すことが出来るはずです。
しかし、マス目が空なのかそれとも半透明の敵駒があるのかまでも明らかになるわけではありません。
このため、私はあるユーザーから「敵の駒が利いていない空のマス目にも目印を付けて欲しい」という要望を受けることになりました。
その解決策として誕生したのが、盤上の「雲(clouds)」です（図7参照）。
「雲」は、そのマス目が敵の攻撃の範囲外にあることを示すためにソフトウェア側で描画された画像です。
プレイヤーは、現在の手番でマス目の中に半透明の敵駒が存在する可能性があり、マス目が空であるかどうかは分からないことに留意します。
ですが、「雲」も駒も存在しないマス目が正真正銘の空っぽであることは明らかです。

![surakarta](http://www.abstractgames.org/uploads/1/1/6/4/116462923/3b1ac327-7a3c-44b5-b7a4-b855af5619a2_orig.png)  
図8：スラカルタ

このような抜本的な変更が、常にゲームの見栄えを良くすることに貢献するとは限りません。
[ガラ(Gala)](https://glukkazan.github.io/control/gala.htm)（"農民のチェス(Farmer's Chess)"としても知られています）のようなゲームでは、駒が移動中に行き先を変えることがあります。
インドネシアの[スラカルタ(Surakarta)](https://glukkazan.github.io/elimination/surakarta.htm)（[AG13](http://www.abstractgames.org/uploads/1/1/6/4/116462923/abstract_games_issue_13.pdf)を参照）というゲームでは、より興味深い状況が見られます。
このゲームにおける「相手の石の捕獲」の概念は、盤に描かれている合計8つのコーナーループのうち少なくとも1つに沿って自分の駒を動かし、相手の駒の上に着地してそれを取るという動作からなっています。
「捕獲」「非捕獲」のどちらの移動も、空のマス目を対象とした任意の方向への単一ステップとして実行されます。
このため、Zillions of Gamesのように「捕獲」の着手を開始位置から終了位置までの直線的な移動として表示すると、「捕獲」の移動が「非捕獲」の移動と混同されてしまう可能性があり、プレイヤーを混乱させるだけになってしまいます。
Dagazにおいては、駒の動きのアニメーション表示が可能なようにしました。
駒や石を動かすと、直線移動・ジグザグ移動・曲線移動のいずれであろうと、駒や石が複数の地点を順番に通過するような動きをしても、その軌道全体がアニメーションとして表示されます。
スラカルタなどの一部のゲームでは、この機能は特に重要です。
また実用的な意味以外でも、この表示は視覚的に優れたグラフィックエフェクトとして機能します。

![the-royal-game-of-ur](http://www.abstractgames.org/uploads/1/1/6/4/116462923/39bd321c-74ec-485b-b023-424e32af2d66_orig.png)  
図10:ウル王朝のゲーム

最後に、[ウル王朝のゲーム(Royal Game of Ur)](https://glukkazan.github.io/races/ur.htm)について触れておきましょう[^royal-game-of-ur]。
このゲームは長い年月の中でルールが完全に失われてしまい、発掘された当初は誰もその遊び方を知りませんでした。
歴史的見地から再現を試みたルールがいくつか提案されていますが、中でも私は[このルール](https://www.ancientgames.org/royal-game-ur-game-20-squares/)が特に好みなんです。これは私の友人であり、作家でボードゲーム普及家のドミトリー・スキュルーク氏が考案したものでもあります。
無論、私がDagazプロジェクトを始めた時、このゲームのことを見逃すことは出来ませんでしたよ！

総括すると、私はボードゲームをより手早く実装するための便利なツールを皆さんにご提案したいと思っています。
DagazはZillions of Gamesプロジェクトのベースとなるアイデアを受け継いでいます。しかしZoGとは異なり、DagazはMITライセンスで公開されている完全オープンソースで無料のソフトウェアです。
現時点では、どのようなボードゲームでも遊べる汎用AIを搭載してはいませんが、思考エンジンをいくつか組み込んであり、必要に応じてそれらを全く別々のルール向けに改造することが可能です。
私は数年間もこのプロジェクトに取り組んでいまして、この短い記事でその全貌をお伝えするのは難しく、説明を端折った部分もあります。
もしも私のプロジェクトにご興味がお有りでしたら、お気軽にメールでご連絡下さい。
私のメールアドレスは[DagazプロジェクトのGitHub Pages](https://glukkazan.github.io/)をご覧下さい。


[^zog]: これ以降の原文では、Zillions of Gamesは単に"Zillions"と略称されていますが、訳文では分かりやすさのため"ZoG"に統一しました。 略していない箇所はそのままにしてあります。また、原文では"ZRF"というドメイン固有言語の構文の制限を"ZoG"というソフトウェア自体の機能の限界として説明している箇所が多いことにも注意して下さい。

[^atari-go]: Wikipediaの言語間リンクを見る限り、アタリ碁(Atari Go)は日本では「ポン抜き囲碁」と呼ばれているそうです。日本においては主に初心者の教育用であり、石を取る感覚を掴んだら卒業するものとされているようですが、個人的には9路盤でやると中々楽しいように思います（訳者が囲碁初心者だからかもしれませんが）。

[^go-rule]: 訳者は囲碁のルールをほとんど知らないため、日本棋院と Wikipedia のルール解説を基にかなり強引に訳しています。誤りがありましたらご指摘頂ければ幸いです。

[^russian-column-checkers]: ロシアン・カラム・チェッカーでは、取った石を自分の石の下へ順番に積み重ねていき、石の "列(column)" を作っていきます。実際に[Dagazのデモ実装](https://glukkazan.github.io/checkers/column-checkers.htm?setup=;0:2;;0:2;+2;0:2+1;;0:2;+5;0:2;;0:2;;0:2;;0:2=0;+10;0:2;+3;0:2=00;;0:2=0000;;0:1;+7;0:1;;0:1;+1;0:1;+2;0:1;;&turn=0)で遊んでみるとどういうことかよく分かると思います。

[^super-ko]: 『一般的なコウのルールと違い、1つ前の自分の着手時の盤面とだけではなく、対局開始からのすべての盤面との同形反復を禁止したルールのこと。三コウの問題が発生しない。』（参考：[囲碁用語辞典](https://www.godictionary.net/term/suupaakou.html)） 中国や欧米で使われるルールのようです。

[^yonin-shogi]: 原文では"a famous Japanese games for four players." 言うほど有名か？変則将棋マニアしか知らんだろ、という気もしますが、[日本語版ウィキペディア](https://ja.wikipedia.org/wiki/%E5%9B%9B%E4%BA%BA%E5%B0%86%E6%A3%8B)によればこち亀で紹介されたこともあったらしいので全く無名ということもなさそうですね。

[^old-shogi]: 原文："As with the other classical Shogi games which are played on small and middle size boards, Yonin Shogi saved the 'drop rule,'..." 古将棋について知識があれば持ち駒を使える将棋類はむしろ少数派に近いというのは明らかなことですが、原著者は将棋のマニアではないので仕方ないかも知れません。

[^royal-game-of-ur]: このゲームの詳細については、[英語版 Wikipedia の該当記事](https://en.wikipedia.org/wiki/Royal_Game_of_Ur)を参照することをオススメします。